## TCP详解

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211214145845785.png" alt="image-20211214145845785" style="zoom:80%;" />

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211214145907108.png" alt="image-20211214145907108" style="zoom:50%;" />

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211214145935147.png" alt="image-20211214145935147" style="zoom:50%;" />

## TCP组成：

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211214150051865.png" alt="image-20211214150051865" style="zoom:80%;" />

序列号：在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传递给接收端主机，每次发送数据，就累加一次该数据字节数的大小，用来解决网络包乱序问题。

确认应答号：指下一次期望收到数据的序列号，发送端收到这个确认应答之后可以认为在这个序号以前的数据都已经被正常接收，用来解决不丢包的问题。

控制位：

ACK 该位为1时，确认应答的字段变为有效，TCP规定除了最初建立连接时候的SYN包之外该位必须设置为1

RST 该位为1时，表示TCP连接中出现异常 必须强制断开连接

SYN 该位为1时，表示希望建立连接，并在其序列号的字段进行序列号初始值的设定

FIN 该位为1时，表示今后不会再有数据发送，希望断开连接，当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位为1的TCP段。

### 为什么需要TCP，TCP在哪一层工作。

**IP层是不可靠的，它不保证网络包的交付、不保证网络包的按序交付、也不保证网络包中的数据的完整性。**

**那么需要保障网络数据包的可靠性，那么就需要由上层（传输层）的TCP协议来负责。**

TCP是工作在传输层的可靠数据传输的服务，他能确保接收端接收到的网络包是无损坏、无间隔、非冗余和按序的。

TCP是**面向连接的、可靠的、基于字节流**的传输层通信协议。

#### 面向连接： 一定是一对一才能连接， 不能像UDP协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的。

#### 可靠的：无论网络链路中出现了怎么样的链路变化，TCP都可以保证一个报文一定能够抵达接收端

#### 字节流：消息是没有边界的，无论我们消息多大都可以进行传输，并且消息是有序的，当前一个消息没有收到的时候即使它先收到了后面的字节，那么也不能扔给应用层去处理，同时对重复的报文会自动丢弃。



TCP连接：指的是用于保护可靠性和流量控制维护的某些状态信息，这些信息的组合，包括Soket（由IP地址和端口号组成）、序列号（用于解决乱序问题）和窗口大小（用于流量控制）成为连接。

**一个TCP可以通过四元组来确定。四元组是指源地址 源端口  目的地址 目的端口**



最大TCP连接数 = 客户端的IP数 * 客户端的端口数

当然服务器端最大的兵法TCP连接数远不能达到理论上限，首先是文件描述符限制Socket，所以首先要通过ulimit配置项目描述符的数目；另一个是内存限制，每一个TCP连接都要占用一定的内存，操作系统的内存是有限的，



### UDP和TCP区别：

UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务，

UDP协议很简单，头部只有8个字节（64位）UDP头部格式如下：

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211214161237305.png" alt="image-20211214161237305" style="zoom:80%;" />

目标和源端口主要是告诉UDP把报文发送到哪个进程

包长度这块字段保存了UDP首部长度跟数据长度之和

校验和为提供可靠的UDP首部和数据而设计

### TCP与UDP区别：

1.连接

TCP是面向连接的传输层协议，传输数据前要先建立连接

UDP是不需要连接，即刻传输数据

2.服务对象

TCP是一对一的两点服务，即一条连接只有两个端点

UDP支持一对一、一对多、多对多的交互通信

3.可靠性

TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按需到达

UDP是尽最大努力交付，不保护可靠交付数据

4.拥塞控制、流量控制

TCP有拥塞阻塞和流量控制机制，保证数据传输的安全性

UDP则没有，即使网络非常拥堵了，也不会影响UDP发送效率

5.首部开销

TCP首部长度较长，会有一定的开销，首部没有使用选项字段时候是20字节，如果使用了选项字段则会变长的。

UDP首部只有8个字节，并且是固定不变的，开销较小。

6.传输方式

TCP是流式传输，没有边界，但保证顺序和可靠。

UDP是一个包一个包的发送是有边界的，但是可能会丢包和乱序。

7.分片不同

TCP的数据大小如果大于MSS（TCP最大报文长度）大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装TCP数据包，如果中途丢失了一个分片，只要传输中途丢失了一个分片，只需要传输丢失的这个分片。

UDP的数据大小如果大于MTU大小，则会在IP层进行分片，目标主机收到后，在IP层组装完数据接着再传给传输层，但是如果中途丢了一个分片，在实现可可靠传输的UDP时就需要重传所有的数据包，这样传输的效率很差，所以通常UDP报文都应该小于MTU（以太网中一般为1500字节）



### TCP和UDP应用场景：

TCP是面向连接，能保证数据的可靠性交付，因此经常用于：

FTP文件传输，HTTP/HTTPS

由于UDP面向无连接，它可以随时发送数据，再加上UDP本身的处理既简单又高效，因此经常用于：

包总量比较少的通信，如DNS SNMP等

视频、音频等多媒体通信

广播通信

为什么UDP头部没有首部长度而TCP有呢

原因是TCP有可以变长的选项字段，而UDP头部长度则是不会变化的，无序多一个字段去记录UDP的首部长度。



## TCP连接建立：

TCP是面向连接的协议，所以使用TCP前必须先建立连接，而建立连接是通过三次握手来进行的

 一开始，客户端和服务端都处于CLOSED状态，先是服务器主动监听某个端口，处于LISTEN状态

第一次握手：

客户端会随机初始化序号，将此序号置于TCP首部字段中，同时把SYN标志位设置为1，表示SYN报文。接着把第一个SYN报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于SYN-SENT状态。

第二次握手：

服务器收到客户端的SYN报文后，首先服务器也随机初始化自己的序号，将此序号填入TCP首部序号字段中，其次TCP首部的确认应答号字段填入client_isn+1 接着把SYN和ACK标志位设置为1，最后把该报文发送给客户端，该报文也不包含应用层数据，之后服务器处于SYN-RCVD状态

第三次握手：

客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文TCP首部ACK标志位设置为1，其次确认应答号字段处填入server_isn +1  最后把报文发送给服务端，这个报文可以携带客户到服务器的数据，之后客户端处于Established状态

服务端接收到客户端的应答报文后也进入Established状态



从上面的过程中可以发现第三次握手是可以携带数据的，而前面两次握手是不可以携带数据的，这也是面试常见的问题，



#### 为什么是三次握手而不是两次？四次？：

三次握手的原因： 

三次握手才能阻止重复历史连接的初始化

三次握手才能**同步双方的初始序列号**（主要原因）

三次握手才能避免资源的浪费

#### 阻止重复历史连接：

**TCP三次握手的首要原因就是为了防止旧的连接初始化造成混乱**

网络环境是错综复杂的，往往并不是和我们预期的一样，先发送的数据包就首先到目标主机，可能由于网络堵塞等乱七八糟的原因，会使得旧的数据包，先到达目标主机，那么这种情况下TCP三次握手就如何避免的？

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215104032629.png" alt="image-20211215104032629" style="zoom:50%;" />

客户端连输发出多次SYN连接报文的，这就是怕旧的连接初始化。

先前发出的旧的SYN报文因为网络堵塞超时，然后客户端发送新的SYN 但是此时旧的SYN先到了，此时服务端确认旧的SYN在把 确认序列号+1（90+1）返回给客户端，客户端根据上下文一比对，发现自己此时要的ACK应该是新发送的SYN的恢复（100+1）于是就**发起了RST报文中止了连接**。等到新的SYN到达服务端，然后服务端返回正确的ACK之后，在继续进行握手操作。

### 同步双方初始序列号：

TCP协议的通信双方，都必须维护一个序列号，**序列号是可靠传输的一个关键因素**，他的作用：

1.接收方可以去除重复的数据

2.接收方可以根据数据包的序列号按序接收

3.可以表示发送出去的数据包中，哪些是已经被对方收到的；

可见，序列号在TCP连接中占据着非常重要的作用，所以当客户端发送携带**初始化序列号**的SYN报文的时候，需要服务端回一个ACK应答报文，表示客户端的SYN报文已经被服务端接受，那么当服务端发送**初始化序列号**给客户端的时候，依然也需要客户端的应答，**这样一来一回，才能确保双方序列号被可靠的同步**

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215110554017.png" alt="image-20211215110554017" style="zoom:50%;" />

**为什么不四次握手？**：本来应该就是四次握手，只是因为第二步，和第三步都是在服务端处理的，可以合并为了一步，这才缩短成了一次握手，所以只需要三次握手， 三次握手本质也是对四次握手的一次优化。

**为什么不两次？**而上面我们讲到只有一来一回的处理，确认一端的序列号同步成功，如果两次的话并不能确定另外一端的序列号同步成功与否。

另外：服务器是不会保存初始化的序列号的，因为是怕受到大量第二次握手请求的攻击，让服务器内存多处挂起导致瘫痪。（SYN攻击）

### 避免资源浪费：

如果只有两次握手，当客户端SYN请求连接在网络中阻塞，客户端没有受到ACK报文，就会重新发送SYN，由于没有第三次握手，服务器也不知道客户端是否收到自己发送的建立连接的ACK确认信号，所以每次收到一个SYN就只能主动建立一个连接。**这就会造成如果客户端的SYN阻塞了重复发送了多次SYN，那么服务器在收到请求之后就会建立多个冗余的无效连接造成资源浪费**

**客户端和服务端初始化序列号ISN不同的原因是** ：

如果一个已经失效的连接被重用了，但是该旧链接的历史报文还残留在网络中，如果序列号相同，那么就无法分辨出该报文是不是历史报文，如果历史报文被新的连接接收了，那么会产生数据错乱。

所以每次建立连接前都要初始化一个序列号是为了通信双方能够根据序号将不属于本连接的报文段丢弃。

另一方面也是为了安全性，防止黑客伪造的相同序列号的TCP报文被对方接收。



## MTU 和MSS

问题： 既然IP层会分片，为什么TCP层还需要MSS呢？

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215113335876.png" alt="image-20211215113335876" style="zoom:80%;" />

MTU： 一个网络包的最大长度      MSS:出去IP头和TCP头后一个网络包所能容纳数据的最大长度

如果TCP报文（头部+数据）交给IP层分片，那么当IP层有一个超过MTU大小的数据要发送，那么IP层就要进行分片，把数据分成若干片，保证每一个分片都小于MTU，把一份IP数据报进行分片以后，由目标主机的IP层进行重新组装货，再交给上一层TCP传输层。

看起来井然有序，但是又隐患的，**如果当一个IP分片丢失了，那么整个IP报文的所有分片都得重传**

因为IP层本身没有超市重传机制，它由传输层的TCP来负责超时和重传。当TCP报文的某一片丢失后，则不会影响ACK给对方，那么发送方的TCP在超时后，就会重发整个TCP报文。

因此，可以看出由IP层来进行分片传输，是非常没有效率的。

所以，为了达到最佳的传输效能TCP协议在**建立连接的时候通常需要协商双方的MSS值**，当TCP层发现数据超过MSS时，则就会先进行分片，当然由它形成的IP包长度也不会大于MTU，自然也不需要IP分片了。

经过TCP分片后，如果一个TCP分片丢失后，进行重发时也是MSS为单位，而不用重传所有的分片，大大增加了重传效率。

## SYN攻击：

TCP连接是需要三次握手的，假设攻击者短时间伪造不同IP地址的SYN报文，那么服务器每次收到一个SYN报文就进入一次SYN_RCVD状态，但服务端发送出去的ACK+SYN报文无法得到未知IP主机的ACK应答，久而久之就会占满服务器SYN接收队列。

解决方式：

1.修改Linux内核参数，控制队列大小和当队列满足时候应该做什么处理。

2.

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215115354063.png" alt="image-20211215115354063" style="zoom:67%;" />

正常流程：

当服务器收到客户端的SYN后，会将其加入内核的SYN队列

接着发送SYN+ACK给客户端，等待客户端回应ACK报文

服务端接收到ACK报文后，从SYN队列移除放入到Accept队列

应用通过调用accpet() socket接口，从Accept队里取出连接。

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215115640198.png" alt="image-20211215115640198" style="zoom:67%;" />

应用程序过慢：

就会导致Accept队列被占满。

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215115719414.png" alt="image-20211215115719414" style="zoom:67%;" />

受到SYN攻击：

如果不断接受到SYN攻击，就会导致SYN队列被占满。

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215115817677.png" alt="image-20211215115817677" style="zoom:67%;" />

当SYN队列满了之后，后续服务器接收到SYN包，不仅如此SYN队列

计算出一个cookie值，再议SYN+ACK的序列号返回给客户端

服务器接收到来自客户端的应答报文时，服务器就会检测这个ACK包的合法性，如果合法直接放入Accept队列

最后应用调用accpet()socket接口，从accept队列中取出连接。

# TCP断开：四次挥手

TCP断开连接的方式是通过四次挥手的方式，双方都可以主动断开连接，断开连接之后主机中的资源被释放。

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215144843428.png" alt="image-20211215144843428" style="zoom:67%;" />

1.客户端准备关闭连接，此时发送一个TCP首部FIN标志位被设置为1的报文，也就是FIN报文，之后客户端进入FIN_WAIT_1状态。

2.服务端收到报文后，就会向客户端先发送一个ACK应答报文接着服务端进入一个Closed_Wait状态。

3.客户端收到服务端的ACK报文后进入FIN_WAIT_2状态

4.等待服务端处理完毕数据后，继续向客户端发送FIN报文，之后服务端进入LAST_ACK状态

​	客户端收到服务器端的FIN报文，然后发送一个ACK给服务器端，并且客户端之后进入TIME_Wait状态。

5.服务端收到了客户端ACK应答报文后，就进入了CLOSED状态，至此服务端已经完成连接的关闭。

6.客户端在经过2MSL一段时间后，自动进入CLOSED状态，至此客户端也完成连接的关闭。

每个方向都需要一个FIN和ACK所以通常被成为四次挥手。

需要注意的一点是：**主动关闭连接的才有Time_WAIT状态。**



**为什么需要四次挥手**：

理解一下双方发FIN的过程，关闭连接时候，服务端收到了来自客户端的FIN，先回一个ACK，但是此时服务端可能还有数据是需要处理和发送的，需要等服务端不再发送数据时候才会跟发FIN报文给客户端。 在握手的过程中，当时是因为建立连接并没有交互数据，所以可以把SYN和ACK合并到一步，但我们在关闭连接的过程中，是在服务器和客户端的交互之后，所以不能将他们合并



**为什么TIME_WAIT等待的时间是2MSL？**

MSL（报文最大生存时间），他是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃，因为TCP报文是基于IP协议的，而IP头中有一个TTL字段，是IP数据报可以经过的最大路由数，每经过一个处理他的路由器此值就减1，当此值为0时候就会被丢弃，同时发送ICMP报文通知源主机。

MSL和TTL的区别： MSL的单位是事件，而TTL是经过路由条数，所以MSL应该要大于等于TTL消耗为0的时间，以确保报文的自动消亡。

**TIME_WAIT = 2MSL**的最合理解释：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待2倍的时间。

**为什么需要TIME_WAIT状态**：

只有**主动发起关闭的一方才会有TIME_WAIT状态**，

需要TIME-WAIT状态，主要是两个原因：

1.防止具有相同四元组的旧数据包被收到

2.保证被动关闭连接的一方能够正确的关闭，即保证最后的ACK能让关闭方接收，从而帮助其正常关闭。



#### 防止旧链接数据包：

假设TIME-WAIT时间没有或者果断，被延迟的数据包抵达的情况：



<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215152921419.png" alt="image-20211215152921419" style="zoom:80%;" />

如图，黄匡框服务端在关闭连接之前发送的SEQ=301报文被网络延迟了，这时候有相同端口的TCP连接被服用后，被延迟的SEQ=301抵达了客户端，那么客户端是有可能正常接收这个过期的报文的，这就会产生数据错乱问题。

所以TCP设计出了这么一个机制就是让经过2MSL这个时间，足以让两个方向上的数据包都被丢弃，是的原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。



#### 保证连接正确关闭：

TIME_WAIT的另一个重要作用是等待足够的时间以确保最后的ACK能让被动关闭防接收，从而帮助其正常关闭。

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211215153505634.png" alt="image-20211215153505634" style="zoom:67%;" />

可以看出上图中红色框框客户端的四次握手中最后一个ACK报文如果在网络中丢失了，此时如果客户端TIME_WAIT果断或者没有，则就直接进入了CLOSED状态了，那么服务端就会一直处在LAST-ACK阶段不能正常关闭。

当客户端发起建立连接的SYN请求报文后，服务端回发送RST报文给客户端，连接建立的过程就会被终止。



如果TIME_WAIT时间等待足够长的情况就会遇到两种情况：

服务器正常说道四次挥手的最后一个ACK报文，服务端正常关闭，

服务器没有正常收到最后一个ACK报文，则会重发FIN关闭连接报文等待新的ACK报文。

所以客户端在TIME-WAIT等待2MSL时间后就可以保证双方都可以正常的关闭，



**TIME_WAIT过多的危害**：

如果服务器有处于TIME_WAIT状态的TCP则说明是由服务器方主动发起的断开请求。

过多的TIME-WAIT状态有两种危害：

1.内存资源占用

2.对端口资源的占用，一个TCP连接至少消耗一个本地端口

第二个危害是会造成严重后果的，要知道端口资源也是有限的，一般可以开启的端口为32768~61000.可也可以通过参数设置，**如果发起连接一方的TIME_WAIT状态过多，占满了所有端口资源则会导致无法创建新连接**

客户端端口资源受限：TIME_WAIT过多导致端口资源被占用，因为端口就65536个，被占满就会导致无法创建新的连接。

服务端受系统资源限制：

由于一个四元组表示TCP连接，理论上服务端可以建立很多连接，服务端确实只监听一个端口但是会把连接扔给处理线程，所以理论上监听的端口可以继续监听，但是线程池处理不了那么多一直不断的连接了。所以当服务器出现大量TIME-WAIT时，系统资源被占满时，会导致处理不过来新的连接。



### time-wait优化：

这里的几种优化方案都是有利有弊的：

1. net,ipv4.tcp_tw_reuse和tcp_timestamps

如下的Linux内核参数开启后，则**可以复用处于TIME-WAIT的socket为新的连接所用。**

有一点需要注意的是，tcp_tw_resuse功能只能用客户端（连接发起方），因为开启了该功能，在调用connect()函数，内核会随机找一个time_wait状态超过1s的连接给新的连接复用（linux内核2msl = 120s）

2.net.ipv4.tcp_max_tw_buckets

这个值默认是18000，当系统中处于TIME_WAIT的连接一旦超过了这个值时，系统就会将后面的TIME_WAIT连接状态重置。

这个方法治标不治本，带来的问题远比解决的问题多。

3.程序中使用so_linger：

我们可以通过设置socket选项来设置调用close关闭连接行为。

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211216102931653.png" alt="image-20211216102931653" style="zoom:67%;" />

如果l_onoff为非0，且l_linger为0那么调用close之后，会立刻发送一个RST标志给对端，该TCP连接跳过四次挥手，直接关闭。但这为跨越TIME_WAIT提供了一个可能，但是也是非常危险的行为。



**如果已经建立连接，客户端突然出现了故障：**

TCP是有保活机制，这个机制的原理是：定义一个时间段，在这个时间段里面，如果没有任何连接相关的活动，TCP保活机制就会开始作用，每隔一段时间发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到相应，则认为当前TCP连接已经死亡，系统内核将错误信息通知给上层应用程序。

开启了TCP保活，需要考虑以下几种情况：

1.对端程序正常，当TCP保活探测报文发送对端正常相应，那么TCP保活时间就会被重置

2.对端程序崩溃并重启，当TCP保活探测报文发送对端后，对端可以响应，但是由于连接没有有效信会产生一个RST报文，这样很快就会发现TCP连接已经被重置

3.是对端程序崩溃，或对端由于其他原因导致报文不可达，当TCP保活的探测报文发送给对端后，石沉大海，连续几次没响应,达到保活探测次数后，TCP会报告该连接已经死亡。



## Socket编程

针对TCP应该如何Socket编程。

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211216104415272.png" alt="image-20211216104415272" style="zoom:50%;" />

服务端和客户端初始化socket，得到文件描述符；

服务端调用 bind ，将绑定在IP地址和端口；

服务端调用listen 进行监听

服务端调用accept 等待客户端连接

客户端调用 connect ，向服务器端的地址和窗口发起连接请求

服务器accpet返回用于传输socket的文件描述符；

客户端调用write写入数据；服务端用read读取数据；

客户断开连接时候，会调用close，那么服务端read读取数据的时候，就会读取到了EOF，待处理完数据后，服务端调用close，表示连接关闭。

**需要注意的是：**服务端调用accept时，连接成功返回一个已完成连接的socket，后续用来传输数据。

所以，监听socket和真正用来传输数据的socket是两个socket，一个叫做**监听socket**，一个叫做**已完成连接连接socket**

连接成功后，双方通过read和write来读写数据，就像往文件流里面写东西一样。

