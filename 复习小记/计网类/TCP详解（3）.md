# TCP详解（3）：三次握手的异常情况分析、

## 流量控制是为了控制发送方占满接收方的缓存区，让发送方根据接收方的能力来发送数据，拥塞避免根据网络情况的变化进行调整

## 第一次握手丢失SYN包：

客户端第一次握手时候发送SYN，在超时时间内没收到服务器的ACK就会在超时重传SYN数据包，每次超时重传的RTO是翻倍上涨（超时重传机制）的，直到SYN包的重传次数达到上限之后，客户端不在继续发送SYN包。

这个重传次数上限是可以设置的，Linux内核默认为5次

## 第二次握手的SYN、ACK包丢失：

客户端发起SYN后，由于某些原因收不到服务器的所有数据包，所以收不到SYN.ACK包，发生超时之后，就会重传SYN包

服务端收到客户端的SYN包后，就会回SYN、ACK包，但是客户端一直没有回ACK，服务端在超时后就会重传SYN.ACK包。接着一会儿，客户端超时重传SYN包又抵达了服务器，服务器收到后**超时计时器**就重新计时，然后回SYN.ACK包 相当于服务器的超时定时器只触发了一次又被重置了。

最后直到客户端SYN重传次数达到了上限之后就不会继续再发送SYN包了。

## 第三次握手的ACK包丢失：

客户端发送SYN包给服务端，服务端接收到了之后，回了一个SYN ACK 包给客户端，此时服务端的TCP连接处于SYN_RECV状态

客户端收到SYN ACK包之后给服务端回了个ACK包，此时客户端处于TCP连接的ESTABLISHED状态

当服务端收不到ACK包时候，所以服务端一直处于SYN_RECV状态没有进入建立状态.

接着服务端超时重传SYN.ACK包重传五次后，也就是超过了重传上限，之后就没有继续重传了，此时服务端TCP连接主动中止了，所以刚才处于SYN_RECV状态的TCP连接断开了，而客户端依然处于ESTABLISHED状态。

虽然服务端TCP断开了，但过了一段时间，发现客户端依然处于ESTABLISHED状态，于是就在客户端的telnet会话输入了123456

由于此时服务器已经断开连接，客户端发送的数据报文一直在超时重传，每一次重传RTO都是指数增长，所以持续了很长一段时间，客户端的telnet才报错退出了，此时共重传了15次。

### 所以可知，第一次握手的tcp_syn_retries的重传次数是5次（默认），而tcp_syn-ack_retries的重传上限次数为15次。

**如果客户端不发送数据，什么时候才会断开ESTABLISHED状态？**：这就需要提到**TCP的保活机制**了，当连续几个探测报文都没有得到相应时候就会断定该TCP连接死亡。



## TCP快速建立连接：

客户端在向服务器发起HTTP GET请求时候一个完整的交互过程需要2.5RTT时延

但是由于**第三次握手是可以携带数据的**，如果此时在第三次握手发起HTTP get请求，需要2个RTT时延

在Linux3.7内核中就开放了TCP fast OPEN 这个功能可以减少TCP连接的时延

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211220170643808.png" alt="image-20211220170643808" style="zoom:67%;" />

在第一次建立连接的时候，**服务器在第二次握手产生一个Cookie（已加密）**通过SYN、ACK包一起发送给客户端，于是客户单就会缓存这个Cookie所以第一次发起HTTP Get请求的时候，还是需要2RTT的时延

但是在下一次请求的时候客户端SYN包中带上Cookie发送给服务器，就提前跳过三次握手过程，因为Cookie中维护了一些信息，服务器可以从Cookie获取TCP相关的信息，这时发起的HTTP GET 请求就只需要1RTT时延。

客户端存储FAST Open Cookie 之后，可以不断重复TCP Fast Open 直至服务器认为Cookie无效（过期）为止。

## TCP重复确认和快速重传：

当接收方接收到乱序数据包时，会发送重复的ACK，以便告诉发送方要重发该数据包，当发送发收到3个重复ACK时候就会触发快速重传机制，立即重发丢失数据包

## TCP流量控制:

为了防止发送方无脑发送数据，导致接收方缓冲区被填满就有了滑动窗口机制，它可以利用接收方的接收窗口来控制发送方要发送的数据量，也就是流量控制。

接收窗口是由接收方指定的值，存储在TCP头部中，它可以告诉发送方自己的TCP缓冲空间区大小，这个缓冲区是给应用程序读取数据的空间：

如果应用程序读取了缓存区的数据，那么缓冲空间区就会把这个读取了的数据移除

如果应用数据没有读取，则数据会一直滞留在缓冲区。

接收方接口的大小，是由TCP三次握手协议中协商好了的，后续数据传输时，接收方确认应答ACK报文时，会携带当前接的接收窗口的大小，以此来告知发送方。

假设接收方接收到数据后，应用层能很快的从缓冲区中读取数据，那么窗口大小会一直保持不变

但是现实是服务器会出现繁忙的情况，当应用程序读取速度慢，那么缓存空间会慢慢被占满，于是为了保证发送方发送的数据不会超过缓冲区大小，服务器则会调整窗口大小的值，接着ACK报文通知给对方，告知现在的接收窗口大小，从而控制发送方的数据大小。

## TCP延迟确定和Nagle算法：

当我们TCP报文的数据非常小只有几字节的时候，那么整个网络的效率就很低了，因为头部报文就要占20个字节，也会有20个字节的IP头部，而数据就那么几个字节，所以效率可见的低。

那么就出现了两种常见的策略来减少小报文传输，分别是：**Nagle和延迟确认**

Nagle算法做了一些策略来避免过多小数据报文发哦是那个，这样可以提高传输效率。

Nagle算法策略：

​	没有已发送未确定报文时，立刻发送数据

​	存在未确定报文时，直到【没有已发送未确定报文】或【数据长度达到MSS大小】时，在发送数据

只要没满足上面一条，发送方就一直囤积数据，直到满足上面一条为止

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211220174301723.png" alt="image-20211220174301723" style="zoom:67%;" />

可以看出**Nagle算法一定会有一个小报文，也就是在最开始的时候。（发送方）**

另外Nagle算法默认是打开的，如果对于一些需要小数据包交互的场景程序，比如telnet或者ssh这样的交互性比较强的程序就需要关闭Nagle算法

可以在Socket的TCP_NODELAY这个选项来关闭这个算法

### 延迟确认策略：（接收方）

事实上当没有携带数据的ACK，他的网络效率也是很低的因为他有40字节的IP头和TCP头，但却没有携带数据报文。

为了解决这种问题，就衍生出了TCP延迟确认的策略。

TCP延迟确认策略：

当有响应数据要发送时，ACK会随着响应数据一起立刻发送给对方

当没有响应数据要发送时，ACK将会延迟一段时间，以等待是否有响应数据一起发送

如果在延迟等待发送ACK期间，对方的第二个数据报文又达到了，这时就会立即发送ACK

