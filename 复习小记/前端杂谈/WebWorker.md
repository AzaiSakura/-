## WebWorker

概述：

Web Workers使得一个Web应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞。

它的作用就是**给JS创造多线程运行环境**，允许主线程创建worker线程，分配任务给后者，主线程运行的同时worker线程也在运行相互不干扰，**在worker线程运行结束后把结果返回给主线程（比如合成器线程和栅格线程这种）**，在worker线程运行结束后把结果返回给主线程，这样做的好处是主线程可以把计算密集型或高延迟的任务交给worker线程执行，这样主线程就会变得轻松，不会被阻塞或者拖慢，这并不意味着JS语言本身就拥有了多线程能力，而是浏览器作为宿主环境提供了一JS一个多线程运行的环境。

**不过因为worker一旦新建，就会一直运行，不会被主线程的活动打断，**这样有利于随时响应主线程的通性，但也会造成资源的浪费，所以不应过渡使用，用完注意关闭。或者说：如果worker无实例引用，该worker空闲后会被立刻关闭；如果worker实例引用不为0，该worker空闲也不会被关闭。



Web worker 兼容性

![img](https://pic2.zhimg.com/80/v2-4631534a9d4c2a2e37abd4b0e6a2dffd_720w.jpg)

### Worker线程的使用也有一些注意点：

同源限制worker线程执行的脚本文件必须和主线程的脚本文件同源，这是当然的了，总不能允许worker线程 到别人电脑上读取文件吧。

文件线程为了安全，worker线程无法读取本地文件，它所加载的脚本必须来自网络，且需要与主线程的脚本同源

DOM操作先知worker线程再与主线程的window不同的另一个全局上下文中运行，其中无法读取主线程所在网页的DOM对象，也不能获取document、window等对象，但是可以获取navigator、location（只读）、XMLHttpRequest、setTimeout族等浏览器API



**通信限制：**worker线程与主线程不在同一个上下文，不能直接通信，需要通过postMessage方法来通信。

**脚本限制：**worker线程不能执行alert、confirm，但可以使用XMLHttpRequest对象来发出ajax请求



## 应用场景：

1、加密数据

有些加密算法比较复杂，或者在加密很多数据的时候，这回非常消耗计算资源，导致UI线程无响应，因此这是使用WebWorker的好时机，使用Worker线程可以让用户更加无缝的操作UI。

2、预取数据

有时候为了提升数据加载速度，可以提前使用Worker线程获取数据，因为Worker线程是可以用XMLHttpRequest的

3、预渲染

在某些渲染场景下，比如渲染复杂的canvas的时候需要计算的效果比如反射、折射、光影、材料、等等，这些计算的逻辑都是可以使用Worker线程来执行的，也可以使用多个Worker线程，这里有个涉嫌追踪的示例。

4、复杂数据处理场景

某些检索、排序、过滤、分析会非常消耗时间，这时可以使用WebWorker来进行，不占用主线程。



