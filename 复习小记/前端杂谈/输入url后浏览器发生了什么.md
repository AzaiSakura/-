## 从打开浏览器到输入url后浏览器发生了什么

操作系统开辟一块内容空间给浏览器（应用），浏览器的各个进程开始执行，打开浏览器界面（分为浏览器进程、缓存进程、GPU进程、网络进程、插件进程、渲染器进程），浏览器有可能会给每个标签页都开启一个**渲染器进程**，（这部分开始是输入url后的过程）当我们在浏览器的搜索栏输入一串网址时候，那么**UI进程会启动一个网络进程来进行DNS域名的解析**（域名解析过程是通过逐级的递归得到网站IP地址的）接着连接服务器内容（这个过程中就包括TLS握手和TCP握手），网络线程获取到数据后该怎么进行=>		

  		1. 首先浏览器的网络线程会对我们的这个站点进行safeBrowsing验证（谷歌内部的站点检测系统），如果有安全问题就会提示我们这个网址有安全问题，当然用户是可以继续访问的
  		2. 当返回数据准备完毕以及安全验证通过时，网络线程会通知UI进程准备就绪，然后UI线程就会创建一个渲染器线程来渲染页面，然后UI线程通过IPC管道通信将数据交给渲染进程，然后渲染器进程开始渲染页面
  		3. 渲染器进程的内容就是将html、css、js等资源渲染成用户可以交互的web页面，渲染进程主线程将

​	3.1 HTML资源构造DOM数据结构（HTML首先通过Tokeniser标记化将html内容解析成多个标记，根据识别之后的标记进行dom树构造，**图片和CSS这些都可能需要网络加载他们都不会影响DOM的生成，但当HTML解析过程中遇到了script标签，就会停止解析转而去加载运行js（这也是为什么要确定scrpit标签放置的位置或者使用defer async关键词来异步加载script标签 async一下载完成会立即执行，但是defer的脚本会在DOMContentLoaded事件之前执行。）**）

​			浏览器为什么会默认先执行script标签呢（原因是浏览器不知道scrpt标签中的js是否会改变dom树结构，如果会那么先构造树结构再用Js那么之前构造的DOM树就没意义了）

​	3.2	此时我们得到了一个DOM树，但我们还不知道每个dom节点该是什么样子的，所以就会通过解析css来确定每个DOM节点的计算样式，然后进入Layout布局

​	3.3    LayoutTree就会就算出每个元素在页面节点的位置（Layouttree和DOMtree不一定相同，因为display:none的元素不会出现在layouttree里面）（这也是为什么DOMTREE控制不了伪类的原因（伪类在laytree中不在domtree中）），之后主线程会制定样式绘制表指定绘制顺序，之后渲染器进程就会对页面进行**合成**（一种高级的图层栅格化）

​	3.4  主线程遍历Layoutree生成图层（layer）树以及绘制顺序表确定后，就会将这些信息传递给合成器线程，之后合成器线程就界面分割成多个图块在分给多个栅格线程进行栅格化，栅格化图块之后就将图块放存储在GPU内存中，当栅格化完成后，就会将栅格化好的信息返回给合成器线程，然后合成器线程就将这些信息生成了合成器帧，然后把合成器帧返回给UI线程，接着浏览器进程将合成器帧传送到GPU，然后GPU渲染展示到屏幕上，这个时候就生成了我们看到的界面内容（**栅格化的整个流程是不占用主线程的只占用合成器线程）**

```
栅格线程和合成器线程都是在渲染器进程中运行的，所以不会占用主进程
渲染器进程负责选项卡内发生的所有事情。在渲染器进程中，主线程处理您发送给用户的大部分代码。如果您使用 Web Worker 或 Service Worker，有时部分 JavaScript 由工作线程处理。合成器和光栅线程也在渲染器进程中运行，以高效流畅地渲染页面。
GPU是现代计算机中图形处理的核心
CPU是电脑各种智能设备的核心组件，作用在于处理指令，执行操作，要求进行动作等。。
```

​	4. 当界面内容滑动时候，合成器线程就会生成新的合成器帧再传给GPU，继续渲染新的内容出来

### 从上面可知 JS引擎线程和GUI渲染线程是相互排斥的，因为JS引擎线程再执行的时候可能要发生重排重绘（重排和重绘是占主线程的，但是栅格化和合成器线程是不会占主线程的）

## 重绘和重排：

当我们改变一个DOM元素的尺寸位置属性时候就会重新进行样式计算、布局、绘制等上述流程，这种行为我们称之为**重排**。

当我们改变某个元素的颜色等属性时候就会重新进行样式计算和绘制（不影响布局），这种行为我们称之为**重绘。**

所以重排和重绘都是会占用主线程，这也是为什么要避免重排重绘的原因

## 减少重排重绘的方式;

重排的成本会比重绘的成本高很多，一个节点的重排可能会导致子节点和父节点的重排，在电脑性能高的电脑上也许并不是什么大事，但是如果重排发生在手机上，那么这个过程是延慢加载和好点的。

方式1： 直接改变className 如果动态改变样式 则使用cssText(考虑没有优化的浏览器)；

方式2：让要操作的元素进行离线处理，处理完后一起更新

​	2.1 使用DocumentFragment进行缓存操作，引发一次重排和重绘

​	2.2 使用display:none ，只引发两次重排重绘

​	2.3 使用cloneNode(true or false)和replaceChild技术，引发一次重排和重绘

方式3：不要经常访问会引起浏览器flush队列的属性，如果确实要访问就利用缓存

方式4：让元素脱离文档流，减少回流的Render Tree 的规模

方式5： 使用transform代替以下六点减少性能消耗

<img src="C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20220303154749851.png" alt="image-20220303154749851" style="zoom: 67%;" />

