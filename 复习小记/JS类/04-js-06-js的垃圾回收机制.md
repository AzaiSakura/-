### js的垃圾回收机制



#### 关于GC

- 程序工作过程中会产生很多垃圾（程序不用的内存或者之前已经使用过以后不会再用的内存空间），而GC（Garbage Collection）就是负责回收垃圾的，工作在引擎内部



#### 垃圾产生？为何回收？

- 创建基本类型、对象、函数...都是需要占用内存的
- 程序的运行占用内存，对于持续运行的服务进程，必须要及时释放内存，否则内存占用就会越来越高，轻则影响系统性能，重则导致进程崩溃



#### 垃圾回收策略

- 标记清除法（在js引擎中最常用的算法）
- 引用计数法



##### 标记清除算法

- 分标记和清除两个阶段：
  - 标记阶段：为所有活动对象做标记
  - 清除阶段：把没有标记（非活动对象）销毁

- 大致过程：
  - 垃圾收集器在运行时会给内存中的所有变量都加上一个标记，假设内存中所有对象都是垃圾，全标记为0
  - 然后从各个根对象（包括但不限于window对象、文档DOM树）开始遍历，把不是垃圾的结点改成1
  - 清理所有标记为0的垃圾，销毁并回收它们所占用的内存空间
  - 最后把内存中所有对象标记为0，等待下一轮回收

- 优点：
  - 实现简单，只有两种标记，使用一位二进制位就可以为其标记

- 缺点：
  - 在清除之后剩余对象的内存位置不变，导致空闲内存空间不连续，出现内存碎片（涉及内存分配问题：内存碎片化，分配速度慢）
  - 解决(标记整理算法)：标记结束之后，将不需要清理的对象向内存的一端移动，最后清理掉边界的内存



##### 引用计数算法

- 早先的一种垃圾回收算法，问题很多，现在不怎么用了
- 将`对象是否不再需要`简化定义为`对象有没有其他对象引用到它`

- 大致过程（跟踪每个变量值被使用的次数）：
  - 当`声明`了一个变量并且将一个引用类型`赋值`给该变量的时候这个值引用次数为1
  - 如果同一个值又`被赋给另一个变量`，那么引用数`加 1`
  - 如果该变量的值`被其他的值覆盖`了，则引用次数`减 1`
  - 当这个值的引用次数变为 0 的时候，说明没有变量在使用，这个值没法被访问了，回收空间，垃圾回收器会在运行的时候清理掉引用次数为 0 的值占用的内存



- 优点：
  - 引用计数算法立即回收垃圾（引用值为0时）、而标记清除算法每隔一段时间清除一次（导致js脚本运行过程中线程必须暂停去执行一段时间的GC）
  - 标记清除算法标记活动对象的同时也需要遍历非活动对象，而引用计数算法只需要在引用时计数

- 缺点：
  - 需要一个计数器（占很大的位置，因为不知道被引用数量的上限）
  - 最严重的问题：无法解决循环引用无法回收的问题



V8优化GC...

