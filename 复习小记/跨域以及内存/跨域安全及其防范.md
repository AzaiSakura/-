## 跨域安全及其防范

### 1.XSS攻击（跨站脚本攻击）：

就是一种在网站上注入js脚本，执行非法操作。

利用网页开发时留下的漏洞（web应用程序对用户的输入过滤不足），巧妙的**将恶意的代码注入到网页中，使用户浏览器加载并执行恶意制造的代码，以达到攻击的效果**。这恶意的代码通常是JS代码，但实际上也可以是JAVA、VBS、ActiveX、Flash或者是普通的HTML。（浏览器不会判断，只要是符合解析，那么就会执行恶意的代码）。可能存在XSS的地方：微博、留言板、聊天室等收集用户输入的地方都可能遭受XSS攻击的风险。**只要你对用户的输入没有严格过滤。盗取各种用户的账号、窃取用户的cookie然后冒充用户甚至是管理员进入网站、劫持用户会话，执行任意操作、刷流量，广告弹窗、网页挂马传播蠕虫病毒、记录用户键盘输入。**



       反射性XSS ：非持久型的XSS，没有长期被放在服务器中，是现在最容易出现的一种XSS 漏洞。当用户在请求某一个URL得治的时候，会携带某一部分数据。当客户端进行访问某一条链接的时候，攻击者就可以将恶意的代码植入到URL中，如果服务器端未对URL的参数做判断或者是过滤，直接就返回相应页面，那么XSS攻击代码就会一起被传输到用户的浏览器，从而出发反射型XSS。可配合短链接实现钓鱼。反射型XSS的payload常常是构造在网站的某一个通过GET传递的参数中。（对应的数据流向是：浏览器---后端---浏览器）
    
      存储型XSS ：存储型XSS又叫做持久型XSS。它是危害最大的XSS。这种类型的XSS可以将恶意的攻击代码持久化的保存在服务器上，然后被显示到HTML页面中。此类型的XSS漏洞经常出现 在用户评论的页面，将攻击者精心构造的恶意代码保存在数据库中。如果其他的用户访问到该页面时就会触发恶意的XSS代码执行，从而窃取用户的信息。（数据流向：浏览器---后端---数据库---后端---浏览器）
    
     DOM型XSS ：DOM是由许多不同类型的节点共同组成，主要由元素节点、文本节点、属性节点。DOM型XSS漏洞是基于文档对象模型的一种漏洞。这种XSS和反射型XSS、存储型XSS的原理上由本质的区别，它的攻击代码不需要服务器解析响应，触发XSS依靠的是浏览器端的DOM解析。客户端上的JS脚本可以访问浏览器的DOM并修改页面的内容，不依赖服务器的数据，直接从浏览器端获得数据并执行。在客户端直接输出DOM内容的时候非常容易触发DOM型XSS漏洞，如doccment.getElementByld("x").innerHTML、doccument.write等。
### 预防：

不信任用户提交的任何内容，**对所有用户提交内容进行可靠的输入验证，**包括**对URL、查询关键字、HTTP头、REFER、POST数据等**，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。尽量采用POST而非GET提交表单；**对“<”，“>”，“；”，“””等字符做过滤；**任何内容输出到页面之前都必须加以en-code，避免不小心把htmltag显示出来。**修改为纯前端渲染，把代码和数据分开**。浏览器先加载静态的HTML，此HTML中不包含任何跟业务相关的数据。

**在cookie中可以设置HttpOnly属性**，这样就无法通过js脚本读取到cookie信息，这样能有效防止XSS攻击，窃取cookie内容，这也增加了cookie的安全性。即便如此也不要将重要信息存入cookie

![image-20211207143040133](C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211207143040133.png)

设置完毕后js脚本是读取不了cookie的，但是可以通过

```
Cookie cookies[] = request.getCookies()
```

来读取cookie

### 2.CSRF攻击（跨站请求伪造攻击）：

这种攻击是一种对网站的恶意利用，是一种跨站的伪造请求，指的是**跨站伪造用户的请求，模拟用户操作主要的危害来自于攻击者盗用用户身份，发送恶意请求**。比如：模拟用户发送邮件，发消息，以及支付、转账等。CSRF通过伪装来自受信任用户的请求，来利用受信任的网站。与XSS相比，CSRF更具危险性。

CSRF攻击能够成功，那**是因为黑客可以完全伪造用户的请求，该请求中所有的用户验证信息都是存在于cookie中的，因此黑客可以在不知道这些验证信息的情况下直接利用用户自己的cookie来通过安全验证**。要抵御CSRF关键在于在请求之中放入黑客不能伪造的信息，并且该信息不存在于Cookie之中

**预防：**1**、重要数据交互采用POST进行接收**，当然POST也不是万能的，伪造一个form表单即可破解。

2、**使用验证码**，只要是涉及到数据交互就先进行验证码验证，这个方法可以完全解决CSRF。

3、出于用户体验考虑，网站不能给所有的操作都加上验证码，因此验证码只能作为一种辅助手段，不能作为主要解决方案。

4、**验证HTTP Referer字段，该字段记录了此次HTTP请求的来源地址，最常见的应用是图片防盗链。**

5、**为每个表单添加令牌token并验证。**

## 3.点击劫持

点击劫持是一种视觉欺骗的攻击手段。攻击者将需要攻击的网站通过 `iframe` 嵌套的方式嵌入自己的网页中，并将 `iframe` 设置为透明，在页面中透出一个按钮诱导用户点击。

**X-FRAME-OPTIONS**

`X-FRAME-OPTIONS` 是一个 HTTP 响应头，在现代浏览器有一个很好的支持。这个 HTTP 响应头 就是为了防御用 `iframe` 嵌套的点击劫持攻击。

该响应头有三个值可选，分别是

- `DENY`，表示页面不允许通过 `iframe` 的方式展示
- `SAMEORIGIN`，表示页面可以在相同域名下通过 `iframe` 的方式展示
- `ALLOW-FROM`，表示页面可以在指定来源的 `iframe` 中展示

## 4.中间人攻击

中间人攻击是攻击方同时与服务端和客户端建立起了连接，并让对方认为连接是安全的，但是实际上整个通信过程都被攻击者控制了。攻击者不仅能获得双方的通信信息，还能修改通信信息。

通常来说不建议使用公共的 Wi-Fi，因为很可能就会发生中间人攻击的情况。如果你在通信的过程中涉及到了某些敏感信息，就完全暴露给攻击方了。

当然防御中间人攻击其实并不难，只需要增加一个安全通道来传输信息。HTTPS 就可以用来防御中间人攻击，但是并不是说使用了 HTTPS 就可以高枕无忧了，因为如果你没有完全关闭 HTTP 访问的话，攻击方可以通过某些方式将 HTTPS 降级为 HTTP 从而实现中间人攻击。

### 

## Post和Get安全性：

对于服务器而言，毫无疑问，Get比Post安全，因为Post会修改服务器上的信息，而Get并不会，因此肯定Get更加安全。

### 但是对于用户而言，Post请求更加安全。

原因：

Post请求的参数会存在请求体中，不会出现在url中而Get的记录会保存在浏览器的上网日志中，也就是说只要通过浏览器日志就能看到你的id，如果是无权限通过id可以获取的网站，可以确定你的账户过去发布了哪些互联网信息。

而使用Post，因为数据不会记录在浏览器的记录，网址访问记录会，会有更大的安全性，无法确定上面类似的用户id。因为Post会提交大量数据，无法记录所有的Post数据，如果记录会导致记录服务器的数据量极大。Post通过HTTPS提交时候是通过ssl加密的，无法获取其中信息，除非进行中间人攻击，但那样代价很大，需要服务器做https信任代理，也不一定好使。

由于GET会邪路url中的数据，可以分析数据规律，进行Json注入攻击，然后通过注入攻击非法获取越权数据。

### 所以，除了做seo，非必要的情况下全部使用Post，尽可能不要使用Get来传输数据

