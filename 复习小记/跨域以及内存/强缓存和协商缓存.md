## 强缓存和协商缓存

HTTP响应头中的Cache-Control和Expires都是用于控制缓存有效期的，当两者同时存在且产生冲突时，Cache-Control的优先级更高。原因在于Expires通过设定具体的时间戳来定义缓存有效期，这在客户端和服务端时间不一致的情况下会造成问题

#### 1.强缓存：

 	Cache-Control：

​		1.Response-Header中：控制强缓存的逻辑

​		2.例如Cache-Control：max-age = 31536000（单位是秒）

​		3.max-age:最大过期时间

​		**4.no-cache:不用强缓存 而是使用Etag，往返对比Etag如果没变就返回304使用协商缓存**

​			**no-store 彻底禁用缓存**

​		5.private:只能最终用户（电脑、浏览器）缓存

​		6.public 可以由中间代理缓存（路由器、代理等）

​		Cache-Control可以由多个字段组成而成，主要以下字段组成

![img](https://images2018.cnblogs.com/blog/940884/201804/940884-20180423141638673-1917674992.png) 

**在没有禁用缓存并且缓存没有超过有效时间的情况下，在此访问这个资源就命中了强缓存，不会向服务器请求资源而是直接从浏览器缓存中取**

\2. **s-maxage** 同 max-age，覆盖 max-age、Expires，但仅适用于共享缓存，在私有缓存中被忽略。

\3. **public** 表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。

\4. **private** 表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。

\5. **no-cache** 强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。

\6. **no-store** 禁止缓存，每次请求都要向服务器重新获取数据。

7、**must-revalidate**指定如果页面是过期的，则去服务器进行获取。这个指令并不常用，就不做过多的讨论了。

Expires

- 同在Response Header中
- 同为控制缓存过期
- 已被Cache-Control代替

#### 2.协商缓存

**若未命中强缓存，则浏览器会将请求发送至服务器。服务器根据http头信息中的Last-Modify/If-Modify-Since或Etag/If-None-Match来判断是否命中协商缓存。如果命中，则http返回码为304，浏览器从缓存中加载资源。**

Last-Modify/if-Modify-Since

浏览器第一次请求一个资源的时候，服务器返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间

![image-20211207151730392](C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211207151730392.png)

**当浏览器再次请求该资源时，发送的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。**

如果命中缓存，则返回http 304状态码，并且不会返回资源内容，并且不会返回Last-Modify。由于对比的服务端时间，所以客户端与服务端时间差距不会导致问题。但是**有时候通过最后修改时间来判断资源是否修改还是不太准确（资源变化了最后修改时间也可以一致）。于是出现了ETag/If-None-Match**

**ETag/If-None-Match** （有时候用LAST-modify判断过期 **不准确**）

与Last-Modify/If-Modify-Since不同的是，Etag/If-None-Match返回的是一个**校验码（**ETag: entity tag）。**ETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化*。ETag值的变更则说明资源状态已经被修改。服务器根据浏览器上发送的If-None-Match值来判断是否命中缓存。**

![image-20211207152257979](C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211207152257979.png)

**Etage强势之处在于：能够根据服务端资源变化而变化，且返回的是响应码更加准确，还能根据服务器的变化情况来变化返回数据**



你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

1. 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新get；
2. 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，if-modified-since能检查到的粒度是秒级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；

1. 某些服务器不能精确的得到文件的最后修改时间。

协商缓存流程：

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->没过期-->返回304状态码-->客户端用缓存的老资源。

如果协商缓存真的过期：

发请求-->看资源是否过期-->过期-->请求服务器-->服务器对比资源是否真的过期-->过期-->返回200状态码-->客户端如第一次接收该资源一样，记下它的cache-control中的max-age、etag、last-modified等。

![image-20211207152556142](C:\Users\11791\AppData\Roaming\Typora\typora-user-images\image-20211207152556142.png)

### 2、启发式缓存阶段

当缓存过期时间的字段一个都没有的时候，浏览器下次并不会直接进入协商阶段，而是先进入启发式缓存阶段，你可以通过关闭服务器，刷新页面来观察。 它根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。 也就是说，**当存有 Last-Modified字段的时候，即使是断网，且强缓存都失效后，也有一定时间是直接读取缓存文件的。 etag是没有这个阶段的。**

